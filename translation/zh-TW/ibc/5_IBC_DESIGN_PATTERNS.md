# 5：IBC 設計模式

**這是區塊鏈間通信協議規範中使用的設計模式的討論。**

**有關 IBC 規範中使用的術語的定義，請參見[此處](./1_IBC_TERMINOLOGY.md) 。**

**有關架構的概述，請參見[此處](./2_IBC_ARCHITECTURE.md) 。**

**有關廣泛的協議設計原則，請參見[此處](./3_IBC_DESIGN_PRINCIPLES.md) 。**

**有關一組範例用例，請參見[此處](./4_IBC_USECASES.md) 。**

## 驗證而非計算

分布式帳本的計算非常昂貴：IBC 處理程序中執行的任何計算都必須複製到所有全節點。因此，當它能僅*驗證*計算結果而不執行計算時，IBC 處理程序應選擇這樣做，並在需要時請求額外的參數。

在某些情況下，驗證和計算沒有成本區別——將兩個數字再次計算相加或驗證兩個數字之和等於一個特定的值都需要一次加法，此時 IBC 處理程序應該選擇那個比較簡單的方法。 但是，在其他情況下，執行計算可能會更加昂貴。例如，連接和通道必須生成唯一的標識符。這可以透過以下方式實現，在創建新通道時，IBC 處理程序會哈希創始區塊狀態並加上隨機數來生成偽隨機標識符——但這需要在鏈上計算哈希函數，這個計算十分昂貴。相反，IBC 處理程序應要求在鏈下執行生成隨機標識符，在創建新的通道時僅驗證沒有使用之前用過的標識符。

## 調用接收器

IBC 處理程序的核心功能是在同一機器上運行的其他模組的介面，因此它可以接受模組發送封包的請求，並且可以將傳入的封包路由到模組。該介面應儘可能最小化，以降低實現的複雜性和對主機狀態機的要求。

因此，核心 IBC 邏輯採用只接收調用的模式，這個和直覺的數據流有所不同 。和大家想的一樣，模組調用 IBC 處理程序來創建連接，通道和發送封包。但是，不是由 IBC 處理程序收到來自另一個鏈的封包時，選擇並調用適當的模組，而是模組本身必須調用 IBC 處理程序上的 `recvPacket`（接受通道創建握手也是一樣）。當調用 `recvPacket` 時，IBC 處理程序將檢查調用模組是否被授權接收和處理封包（基於附帶的證明和連接/通道的已知狀態），執行適當的狀態更新（遞增序號以防止重放攻擊），並將控制權返回給模組或拋出錯誤。 IBC 處理程序不直接調用模組。

儘管一開始理解起來有點違反直覺，但這種模式有一些明顯的優點：

- 主機狀態機的要求被降至最低，因為 IBC 處理程序不需要了解如何調用其他模組或存儲對它們的任何引用。
- 它避免了在處理程序狀態裡維護一個模組查找表的必要。
- 它避免了模組返回數據或錯誤。如果某個模組不想收到一個封包（也許已經在上層實現了額外的認證），它只需要簡單的不去調用 `recvPacket` 就可以了。如果路由邏輯是在 IBC 處理程序中實現的，那麼處理程序將需要處理模組的錯誤，這很難解讀。

但此模式有一個明顯的缺點：

- 如果沒有額外的抽象，中繼器邏輯會變得更加複雜，因為鏈下中繼器進程將需要跟蹤多個模組的狀態，以確定何時提交封包。

因此，需要一個額外的 IBC “路由模組”，它暴露一個調用分發介面。

## 調用分發

對於常見的中繼模式，可以實現一個“IBC 路由模組”，該模組維護一個模組分發表來簡化中繼器的工作。

在調用分發模式中，數據報（包含在主機狀態機定義的交易類型中）直接中繼到路由模組，然後路由模組查找適當的模組（擁有數據報所定址的通道和埠）並調用適當的函數（該函數必須事先已註冊在路由模組中）。允許模組不去直接處理數據報，使得與發送或接收封包同時發生的原子狀態轉換執行被意外搞亂變得更加困難（因為該模組從不直接處理封包，而只是向路由模組暴露收到合法封包後調用的函數）。

此外，路由模組可以實現用於握手數據報處理（根據模組的行為接受傳入的握手消息）的默認邏輯，這對於不需要實現自己的自訂邏輯的模組很方便。
