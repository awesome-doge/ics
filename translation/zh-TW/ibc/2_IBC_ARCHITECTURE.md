# 2：區塊鏈間通信協議架構

**這是 IBC 協議的高層次架構和數據流的概述。**

**有關 IBC 規範中使用的術語的定義，請參見[此處](./1_IBC_TERMINOLOGY.md) 。**

**有關廣泛的協議設計原則，請參見[此處](./3_IBC_DESIGN_PRINCIPLES.md) 。**

**有關一組範例用例，請參見[此處](./4_IBC_USECASES.md) 。**

**有關設計模式的討論，請參見[此處](./5_IBC_DESIGN_PATTERNS.md) 。**

本文件概述了區塊鏈間通信協議（IBC）協議棧中身份認證，傳輸和排序層的大致架構。本文件沒有描述特定的協議詳細訊息-它們包含在各個 ICS 中。

> 注意： *帳本* ， *鏈*和*區塊鏈*根據其通俗用法在本文件中可互換使用。

## 什麼是 IBC？

*區塊鏈間通信協議*是一種可靠且安全的模組間通信協議，其中模組是在獨立機器上運行的確定性進程，包括多副本狀態機（例如“區塊鏈”或“分布式帳本”）。

任何基於可靠且安全的模組間通信的應用程式都可以使用 IBC。範例應用程式包括跨鏈資產轉移，原子交換，多鏈智慧合約（不論是否擁有相互可理解的虛擬機）以及各種數據和代碼分片應用。

## IBC 不是什麼？

IBC 不是應用層協議：它僅處理數據傳輸，身份認證和可靠性。

IBC 不是原子交換協議：它支持任意跨鏈數據傳輸和計算。

IBC 不是通證轉移協議：通證轉移是 IBC 協議上的一種可能的應用層場景。

IBC 不是分片協議：不是將單個狀態機拆分成鏈，而是在不同鏈上的不同狀態機共享一些公共介面。

IBC 不是二層擴容協議：所有實現 IBC 的鏈都存在於同一“層”上，儘管它們可能位據網路拓撲中的不同位置，但唯一的根鏈或唯一的驗證人集合不是必須的。

## 動機

在撰寫本文時，兩個主要的區塊鏈，比特幣和以太坊目前分別支持每秒約 7 和 20 筆交易。儘管主要用戶群還是那些早期採用者，兩條鏈在最近的幾年中一直處於滿負荷狀態運行。吞吐量是大多數區塊鏈使用場景的限制，而吞吐量根本上受限於分布式狀態機，因為網路中的每個（驗證）節點都必須處理每筆交易（拋開未來基於零知識的結構，這目前超出了範圍） ，存儲所有狀態，並與其他驗證節點通信。更快的共識算法（例如 [Tendermint](https://github.com/tendermint/tendermint) ）或許可以將吞吐量提高一個很大的常數因子，但是由於這個原因仍無法無限擴展。為了支持促進分布式帳本應用程式廣泛部署所需的交易吞吐量，多樣性和成本效率，必須同時執行多個獨立的共識實例，並分離之間的執行和存儲。

一種設計方向被稱作“分片”，是切片單個可編程狀態機為不同的鏈，這些鏈同時執行並存儲狀態的不相交分區。為了探討安全性和活性，並正確的在分片之間路由數據和代碼，這個設計必須採取“自上而下的方法” —構建特定的網路拓撲，特徵是單個根帳本和一個星狀或樹狀分片結構，並用工程協議規則和激勵措施強制實施該拓撲。這種方法在簡單性和可預測性方面具有優勢，但面臨著嚴峻的[技術](https://medium.com/nearprotocol/the-authoritative-guide-to-blockchain-sharding-part-1-1b53ed31e060) [問題](https://medium.com/nearprotocol/unsolved-problems-in-blockchain-sharding-2327d6517f43) ，要求所有分片都遵循單個驗證人集合（或隨機選擇的子集）和單個狀態機或相互可理解的虛擬機，並且可能會面臨未來的社會可擴展性問題，因為有必要就網路拓撲的變更達成全球共識。

此外，任何單一的共識算法，狀態機和抗女巫攻擊個體都可能無法提供必要的安全性和多樣性。共識實例受其支持的獨立運營者數量的限制，這意味著，破壞特定運營者所獲得的平攤收益會隨著共識實例保有的價值增加而增加，而破壞運營者的成本則始終依照最經濟的方式（例如物理金鑰洩露或社會工程學），這幾乎不會無限增加。單個全局狀態機必須迎合多樣化應用程式集的共同點，因此與專用狀態機相比，它不太適合任何特定應用程式。單個共識實例的運營者可能會濫用其特權地位，從無法輕易選擇退出的應用程式中提取租金。最好構造一種機制，通過該機制，獨立的主權共識實例和狀態機可以安全，自願的交互，同時僅共享最小化的必需的公共介面。

*區塊鏈間通信協議*對擴容和互操作性問題的不同表示形式採用了不同的方法：實現以未知拓撲排列的異構分布式帳本網路的安全，可靠的互操作，在可能的情況下保留保密性，使帳本可以多樣化，彼此獨立或獨立於特定的拓撲或狀態機設計進行開發和重組。在廣泛的，動態的互操作鏈網路中，預期會出現零星的拜占庭錯誤，因此該協議還必須根據所涉及的應用程式和帳本的要求來檢測，紓解並包含拜占庭錯誤的潛在損害。有關設計原則的詳細列表，請參見[此處](./3_IBC_DESIGN_PRINCIPLES.md) 。

為了促進這種異構互操作，區塊間鏈通信協議採用“自下而上”的方法，指定實現兩個帳本之間的互操作所必需的一組要求，函數和屬性，然後指定可能構成多個互操作帳本的不同方式，帳本保留更高級別協議的要求，並在安全/速度折衷空間中占據不同的位置。因此，IBC 不做任何假設，也不需要知道整個網路拓撲和帳本的實現，只需要知道的最小函數集和屬性即可。實際上，在 IBC 中帳本被定義為輕用戶端的一些共識驗證函數，從而擴展了“帳本”的含義，包括了單一機器和類似的複雜共識算法。

IBC 是一種端到端，面向連接的狀態協議，用於在獨立計算機上的模組之間進行可靠的，有序的（可選）、帶身份認證的通信。預計 IBC 實現將與主機狀態機上的更高級別的模組和協議共存。承載 IBC 的狀態機必須提供一組特定的功能來驗證共識記錄和生成加密承諾證明，並且 IBC 封包中繼器（鏈下進程）應能夠訪問網路協議和物理數據連結，以讀取一台機器的狀態，然後將數據提交給另一台機器。

## 範圍

IBC 處理在不同機器的模組之間被中繼的結構化封包的身份認證、傳輸和排序工作。該協議是在兩台機器上的模組之間定義的，但設計可以安全的同時用於以任意拓撲連接的任意數量的機器上的任意數量的模組之間。

## 介面

IBC 位於兩類模組之間，一類是智慧合約，其他狀態機組件或狀態機上其他獨立的應用程式邏輯部分，另一類是基礎共識協議，機器和網路基礎結構（例如 TCP/IP）。

IBC 為模組提供了一組函數，類似於為與同一狀態機上的另一個模組進行交互的模組可能提供的函數：在已建立的連接和通道上發送封包和接收封包（用於身份認證和排序的原語，請參閱[定義](./1_IBC_TERMINOLOGY.md) ）-除了用於管理協議狀態的調用之外：創建和關閉連接/通道，選擇連接/通道，封包傳遞選項以及檢視連接和通道狀態。

IBC 假定 [ICS 2](../../spec/ics-002-client-semantics) 中定義的底層共識協議和機器的功能和特性，主要是最終性（或閾值最終性小工具），可廉價驗證的共識記錄和簡單的鍵/值存儲功能。在網路方面，IBC 僅需要最終的數據傳遞-不假定身份認證，同步或有序屬性（這些屬性將在稍後精確定義）。

### 協議關係

```
+------------------------------+                           +------------------------------+
| Distributed Ledger A         |                           | Distributed Ledger B         |
|                              |                           |                              |
| +--------------------------+ |                           | +--------------------------+ |
| | State Machine            | |                           | | State Machine            | |
| |                          | |                           | |                          | |
| | +----------+     +-----+ | |        +---------+        | | +-----+     +----------+ | |
| | | Module A | <-> | IBC | | | <----> | Relayer | <----> | | | IBC | <-> | Module B | | |
| | +----------+     +-----+ | |        +---------+        | | +-----+     +----------+ | |
| +--------------------------+ |                           | +--------------------------+ |
+------------------------------+                           +------------------------------+
```

## 運作方式

IBC 的主要目的是在獨立主機上運行的模組之間提供可靠的，經過身份認證的有序通信。這需要以下領域的協議邏輯：

- 數據中繼
- 數據保密性和易讀性
- 可靠性
- 流控
- 身份認證
- 富狀態性
- 多路復用
- 序列化

以下各段概述了 IBC 中每個領域的協議邏輯。

### 數據中繼

在 IBC 體系結構中，模組不是透過網路基礎結構直接向彼此發送消息，而是創建要發送的消息，然後通過負責監視的“中繼器進程”對消息進行物理中繼。 IBC 假定存在一組中繼器進程，這些中繼器進程可以訪問基礎網路協議堆棧（可能是 TCP/IP，UDP/IP 或 QUIC/IP）和物理互連基礎設施。這些中繼器進程監視一組實現 IBC 協議的機器，連續掃描每台機器的狀態，當有傳出封包提交時，中繼器進程就到另一台機器上執行交易。為了正常操作和處理在兩台機器之間的連接，IBC 僅要求至少存在一個可以在機器之間進行中繼的正確且活躍的中繼器進程。

### 數據保密性和易讀性

IBC 協議僅要求可以正確操作 IBC 協議所需的最少數據，使協議可用且易讀（以標準格式序列化），並且狀態機可以選擇使該數據僅對特定中繼器可用（但這裡的細節超出本規範的範圍）。這些封包括共識狀態，用戶端，連接，通道和封包訊息，以及構造狀態中特定鍵/值對的包含或不包含證明所必需的任何輔助狀態結構。所有必須證明給另一台機器的數據也必須易讀；即必須以本規範定義的格式序列化。

### 可靠性

網路層和中繼器進程可能以任意方式運行，丟棄，亂序或發送重複封包，故意嘗試發送非法交易或進行其他拜占庭錯誤方式的操作。這必須不能損害 IBC 的安全性和活性。可靠性是通過為 IBC 連接（在發送時）發送的每個封包分配一個序號來實現的，該序號由接收機上的 IBC 處理模組（實現 IBC 協議的狀態機部分）檢查並提供一種發送機在發送更多封包或採取進一步措施之前檢查接收計算機實際上是否已接收並處理了封包的方法。加密承諾用於防止數據報偽造：發送方機器承諾傳出封包，而接收方計算機檢查這些加密承諾，因此被中繼器在傳輸過程中更改的數據報將被拒絕。IBC 還支持無序通道，該通道不強制要求封包的接收符合發送的封包順序，但仍強制執行僅一次送達。

### 流控

IBC 沒有提供計算層面或經濟層面的流控規定。底層機器將具有自己的計算吞吐量限制和流控機制（例如“gas 費用”市場）。應用程式層面的經濟流控（根據其內容限制特定封包的速率）可能對確保安全性（限制一台機器上的值）以及抑制拜占庭行為造成的損害（允許在挑戰期內提交矛盾行為證明，然後關閉連接）有用。例如，通過 IBC 通道轉移價值的應用程式可能希望限制每個塊的價值轉移率，以限制潛在的拜占庭行為所造成的損害。IBC 為模組提供了拒絕封包的功能，並將細節留給了更高級別的應用程式協議。

### 身份認證

IBC 中的所有數據報都經過了身份認證：由發送機的共識算法敲定的塊必須給發送出的封包提供加密承諾，並且接收鏈的 IBC 處理模組必須驗證封包被發送的共識記錄和加密承諾證明，之後才可以使用它。

### 富狀態性

如上所述，可靠性，流控和身份認證要求 IBC 初始化並維護每個數據流的某些狀態訊息。此訊息分為兩個抽象：連接和通道。每個連接對象都包含有關已連接計算機的共識狀態的訊息。特定於一對模組的每個通道都包含有關協商的編碼和多路復用選項以及狀態和序號的訊息。當兩個模組希望進行通信時，它們必須在其兩台機器之間找到一個現有的連接和通道，如果不存在則初始化一個新的連接和通道。初始化連接和通道需要多步握手，一旦完成，就確保了在這個連接下僅連接了兩個目標機器，兩個模組，並對將來的數據報進行身份認證，編碼，對於通道，還需要保證排序。

### 多路復用

為了允許單個主機中的多個模組同時使用 IBC 連接，IBC 在每個連接中提供了一組通道，每個通道的數據流擁有唯一標識，所以封包可以按順序發送（在有序的情況下） ，並且接收方機器上始終保持僅一次送達。通常希望通道與每台機器上的單個模組關聯，但是一對多和多對一的通道也是可能的。通道的數量是無限的，這有助於並發吞吐量僅受限於底層計算機的吞吐量，而且僅需一個連接即可跟蹤共識訊息（該連接的所有通道分攤了共識記錄驗證成本）。

### 序列化

IBC 充當了彼此無法理解的機器之間的介面邊界，並且必須提供必要的最少的數據結構編碼和數據報格式集，以允許兩台都正確實現協議的機器相互理解。為此，IBC 規範在此倉庫中定義了以 proto3 格式提供了在通過 IBC 進行通信的兩台機器之間進行序列化，中繼或證明檢查的數據結構的典範編碼。

> 注意，proto3 的一個子集提供了典範的編碼（相同的結構始終序列化為相同的位元組）。因此，禁止使用 map 和未知欄位。

## 數據流

IBC 可以概念化為一個分層協議棧，數據從上到下（在發送 IBC 封包時）或自下而上（在接收 IBC 封包時）經過協議棧。

“處理程序”是狀態機中實現 IBC 協議的一部分，該狀態機負責將模組或封包的調用進行轉換，並適當的路由這些調用到通道和連接。

考慮兩條鏈 *A* 和 *B* 之間的 IBC 封包的路徑：

### 圖表

```
+---------------------------------------------------------------------------------------------+
| Distributed Ledger A                                                                        |
|                                                                                             |
| +----------+     +----------------------------------------------------------+               |
| |          |     | IBC Module                                               |               |
| | Module A | --> |                                                          | --> Consensus |
| |          |     | Handler --> Packet --> Channel --> Connection --> Client |               |
| +----------+     +----------------------------------------------------------+               |
+---------------------------------------------------------------------------------------------+

    +---------+
==> | Relayer | ==>
    +---------+

+--------------------------------------------------------------------------------------------+
| Distributed Ledger B                                                                       |
|                                                                                            |
|               +---------------------------------------------------------+     +----------+ |
|               | IBC Module                                              |     |          | |
| Consensus --> |                                                         | --> | Module B | |
|               | Client -> Connection --> Channel --> Packet --> Handler |     |          | |
|               +---------------------------------------------------------+     +----------+ |
+--------------------------------------------------------------------------------------------+
```

### 步驟

1. 在鏈 *A* 上
    1. 模組（取決於應用）
    2. 處理程序（在不同的 ICS 中定義）
    3. 封包（在 [ICS 4](../spec/ics-004-channel-and-packet-semantics) 中定義）
    4. 通道（在 [ICS 4](../spec/ics-004-channel-and-packet-semantics) 中定義）
    5. 連接（在 [ICS 3](../spec/ics-003-connection-semantics) 中定義）
    6. 用戶端（在 [ICS 2](../spec/ics-002-client-semantics) 中定義）
    7. 共識（與傳出封包確認交易）
2. 鏈下
    1. 中繼器（在 [ICS 18](../spec/ics-018-relayer-algorithms) 中定義）
3. 在鏈 *B* 上
    1. 共識（確認傳入封包的交易）
    2. 用戶端（在 [ICS 2](/../spec/ics-002-client-semantics) 中定義）
    3. 連接（在 [ICS 3](/../spec/ics-003-connection-semantics) 中定義）
    4. 通道（在 [ICS 4](/../spec/ics-004-channel-and-packet-semantics) 中定義）
    5. 封包（在 [ICS 4](/../spec/ics-004-channel-and-packet-semantics) 中定義）
    6. 處理程序（在不同的 ICS 中定義）
    7. 模組（取決於應用）
